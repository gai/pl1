#LyX 1.6.7 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass heb-article
\begin_preamble
\usepackage{fullpage}
\end_preamble
\use_default_options true
\language hebrew
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
שפות תכנות - ש.ב.

\family roman
\series medium
\shape up
\size largest
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\numeric on
\bar default
\noun default
\color inherit
6
\end_layout

\begin_layout Author
עמרי גיא 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash

\backslash
 065982415
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
R{גיא שקד}
\backslash

\backslash
036567055
\end_layout

\end_inset


\end_layout

\begin_layout Section*
פרולוג כללי
\end_layout

\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $\mbox{-point\left(A,B\right)=point\left(X,Y,Z\right)}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
כאן 
\begin_inset Formula $S,T$
\end_inset

 הם שמות עצם מורכבים ו-
\begin_inset Formula $n\ne m$
\end_inset

, לכן פרולוג לא מספק את המטרה הזו
\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\mbox{-date\left(D,M,1983\right)=date\left(D1,may,Y1\right),date\left(D,M,1983\right)=date\left(15,M,Y\right)}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
פרולוג מספק את המטרה הזו -
\end_layout

\begin_layout Itemize
\begin_inset Formula $\mbox{date\left(D,M,1983\right)=date\left(D1,may,Y1\right)}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
כאן 
\begin_inset Formula $S,T$
\end_inset

 הם שמות עצם מורכבים, יש להם אותו 
\begin_inset Formula $functor$
\end_inset

 ראשי ו-
\begin_inset Formula $m=n$
\end_inset

 לכן פרולוג מבצע את ההתאמה - 
\end_layout

\begin_layout Itemize
\begin_inset Formula $D=D1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $M=may$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Y1=1983$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $\mbox{date\left(D,M,1983\right)=date\left(15,M,Y\right)}$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
כאן 
\begin_inset Formula $S,T$
\end_inset

 הם שמות עצם מורכבים, יש להם אותו 
\begin_inset Formula $functor$
\end_inset

 ראשי ו-
\begin_inset Formula $m=n$
\end_inset

 לכן פרולוג מבצע את ההתאמה - 
\end_layout

\begin_layout Itemize
\begin_inset Formula $D=15$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $Y=1983$
\end_inset


\end_layout

\begin_layout Standard
ובסך הכל המטרה מסופקת ו-
\begin_inset Formula $D=15,D1=15,M=may,Y=1983,Y1=1983$
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Enumerate
כאשר האלגוריתם המוצג בשאלה מנסה להתמודד עם - 
\begin_inset Formula $\mbox{-g\left(X,f\left(X\right)\right)=g\left(f\left(X\right),X\right)}$
\end_inset

הוא מנסה לבצע את ההצבה - 
\begin_inset Formula \[
X=f\left(X\right)\]

\end_inset

ולכן מנסה לבצע את ההצבה - 
\begin_inset Formula $X=f\left(f\left(X\right)\right)$
\end_inset

, וכך הלאה - 
\begin_inset Formula $X=f\left(f\left(\dots f\left(X\right)\right)\right)$
\end_inset

 עד לאינסוף.
 ההצבות לא יעצרו לעולם )אלא באופן מלאכותי, על ידי חריגה ממחסנית הרקורסיה
 למשל( ולכן פרולוג לא יוכל לספק את המטרה.
\end_layout

\begin_deeper
\begin_layout Standard
כאשר מציבים מטרה זו בפרולוג מקבלים - 
\begin_inset Formula \[
\mbox{X = f(**).}\]

\end_inset

כאשר המשמעות היא שפרולוג זיהה את ההפניה המעגלית.
\end_layout

\end_deeper
\begin_layout Subsection*
חתכים
\family roman
\series bold
\shape up
\size large
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
cuts
\end_layout

\begin_layout Enumerate
ה-
\lang english
cut
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
הוא
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
red cut
\lang hebrew
, הוא משפיע על המשמעות של 
\begin_inset Formula $p$
\end_inset

.
 למשל - ללא ה-
\lang english
cut
\lang hebrew
 המטרה 
\begin_inset Formula $\mbox{-p\left(X\right),X>2}$
\end_inset

 תתקבל )פרולוג ינסה את 
\begin_inset Formula $p\left(1\right)$
\end_inset

, 
\begin_inset Formula $p\left(2\right)$
\end_inset

, ויצליח ב-
\begin_inset Formula $p\left(3\right)$
\end_inset

(.
 אבל כאשר ה-
\lang english
cut
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
קיים המטרה לא תתקבל )פרולוג ינסה את 
\begin_inset Formula $p\left(1\right)$
\end_inset

, אחריו את 
\begin_inset Formula $p\left(2\right)$
\end_inset

 - ואז יעצור וידחה(.
\end_layout

\begin_layout Enumerate
בתהליך החישוב של השאילתה מנסה פרולוג למצוא הצבה שתספק את 
\lang english
X
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
)נמצא אחד שכזה - 
\lang english
X=1
\lang hebrew
(.
 לאחר מכן משמעות סימן הקריאה הינו שמעתה ערכו של 
\lang english
X
\lang hebrew
 לא ישתנה )לא יבוצע 
\lang english
backtracking
\lang hebrew
 מנקודה זאת( ולאחר מכן מנסה פרולוג למצוא הצבה שתספק את 
\lang english
Y
\lang hebrew
 וכמובן שגם כזאת נמצאת 
\lang english
Y=1
\lang hebrew
.
\end_layout

\begin_layout Enumerate
ה-
\lang english
CUT
\lang hebrew
 בתכנית מספר אחת הינו 
\lang english
GREEN CUT
\lang hebrew
 מכיון שהחוקים הינם זרים זה לזה ולכן אם מתקיים ש-
\lang english
X
\lang hebrew
 קטן משלוש התנאי השני ממילא לא מתקיים ולכן אין משמעות לכך שלא נאפשר את בדיקת
 התנאי השני.
 לעומת זאת, בתכנית השנייה החוקים אינם זרים, ולכן גם אם מתקיים ש-
\lang english
X
\lang hebrew
 קטן משלוש יכולה להיות השמה שתספק את התוכנית בהתאם לחוק השני בלבד אך זה
 כלל אינו נבדק ברגע שמתקיים כי 
\lang english
X
\lang hebrew
 קטן משלוש, לכן ה-
\lang english
CUT
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
הינו
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
\lang english
RED CUT
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none
\lang hebrew
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default
\color inherit
)למשל עבור, 
\begin_inset Formula $p(2,7)$
\end_inset

 - ללא החתך הפרדיקט יסתפק, אך בניסוח הנוכחי לא(.
\end_layout

\begin_layout Section*
רשימות
\end_layout

\begin_layout Enumerate
מימשנו את הפרדיקט 
\begin_inset Formula $list$
\end_inset

 המסתפק עבור רשימה ריקה או עבור רשימה שמכילה איבר 
\begin_inset Formula $head$
\end_inset

 כלשהו ו-
\begin_inset Formula $tail$
\end_inset

 כלשהו.
\end_layout

\begin_layout Enumerate
מימשנו את הפרדיקט 
\begin_inset Formula $insert$
\end_inset

 המסתפק עבור הוספה של איבר בודד לרשימה ריקה.
 אם הרשימה אליה מנסים להוסיף את האיבר אינר ריקה - הפרדיקט יסתפק -
\end_layout

\begin_deeper
\begin_layout Enumerate
אם ראש הרשימה קטן המאיבר - אם הפרדיקט מסתפק כאשר מנסים להוסיף את אותו איבר
 לזנב הרשימה.
\end_layout

\begin_layout Enumerate
אם ראש הרשימה אינו קטן מהאיבר - אם רשימת התוצאה זהה לשרשור של האיבר החדש
 בתחילת הרשימה הקיימת.
\end_layout

\begin_layout Standard
מימשנו את הפרדיקט 
\begin_inset Formula $insertsort$
\end_inset

 המשתמש ב-
\begin_inset Formula $insert$
\end_inset

 על לקבוע האם רשימה אחת מתקבלת מאחרת על ידי מיון.
 המיון מתבצע בשיטת 
\begin_inset Formula $insert\ sort$
\end_inset

 על ידי קריאה רקורסיבית לפרדיקט והכנסת איבר איבר לרשימה הממויינת המתקבלת
 באמצעות הפרדיקט 
\begin_inset Formula $insert$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
מימשנו את הפרדיקט 
\begin_inset Formula $swap$
\end_inset

 המסתפק אמ"מ הרשימה השניה שניתנה לו מתקבלת מהראשונה על ידי החלפת זוג האיברים
 הראשונים שאינם ממויינים.
 הפרדיקט טרוויאלי עבור רשימות בנות שני איברים, עבור רשימות בנות שלושה איברים
 או יותר - הפרדיקט בודק האם האיברים הראשונים זהים בשתי הרשימות, במקרה כזה
 - אם האיבר הבא ברשימת הקלט גדול או שווה לאיבר הראשון - הפרדיקט נקרא רקורסיבית
 על זנבות הרשימות.
 אם ראשי הרשימות זהים - הפרדיקט יבדוק אם אכן האיברים הבאים מתאימים להחלפה
 תקינה וזנבות הרשימה תקינים - ויסתפק בהתאם.
\end_layout

\begin_deeper
\begin_layout Standard
מימשנו את הפרדיקט 
\begin_inset Formula $bubblesort$
\end_inset

 הקורא לעצמו רקורסיבית כל עוד ניתן להפעיל את 
\begin_inset Formula $swap$
\end_inset

 על הרשימה הראשונה שניתנה לו.
 לאחר שלא ניתן עוד להפעיל את 
\begin_inset Formula $swap$
\end_inset

 )כלומר - הרשימה הראשונה ממוינת( הוא משווה בין שתי הרשימות.
\end_layout

\end_deeper
\begin_layout Enumerate
\begin_inset ERT
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Enumerate
מימשנו את הפרדיקט 
\begin_inset Formula $mymerge$
\end_inset

 המסתפק אמ"מ הרשימה השלישית שניתנת לו ממויינת ומתקבלת ממיזוג שתי הראשונות
 )אנו מניחים כי הן ממויינות(.
 הפרדיקט פועל רקורסיבית כאשר בכל פעם הוא משווה את האיבר הראשון ברשימה השלישית
 לקטן מבין שני האיברים הראשונים של שתי הרשימות האחרות.
\end_layout

\begin_layout Enumerate
מימשנו את הפרדיקט 
\begin_inset Formula $divide$
\end_inset

 המסתפק אמ"מ שתי הרשימות הראשונות שניתנות לו מרכיבות יחדיו את השלישית, ו)כמעט(
 זהות באורכן.
 בכל צעד רקורסיבי הפרדיקט משווה את האיבר הראשון ברשימה השלישית לאיבר הראשון
 ברשימה הראשונה, ואת האיבר השני ברשימה השלישית לראשון ברשימה השניה.
 כאשר הרשימה השלישית היא בת איבר אחד בדיוק - נדרוש שהרשימה השניה תהיה ריקה
 והראשונה בת אותו איבר.
\end_layout

\begin_deeper
\begin_layout Standard
מימשנו את הפרדיקט 
\begin_inset Formula $mergesort$
\end_inset

 המסתפק אמ"מ הרשימה השניה מתקבלת ממיון של הראשונה.
 המיון מתבצע באמצעות חלוקת הרשימה הראשונה לשתי תתי רשימות, קריאה רקורסיבית
 לפרדיקט, איחוד שתי הרשימות הממויינות באמצעות 
\begin_inset Formula $mymerge$
\end_inset

 ולבסוף השוואה לרשימה השניה.
\end_layout

\end_deeper
\end_deeper
\begin_layout Section*
עצים
\end_layout

\begin_layout Enumerate
שמות העצם המתאימים לעצים - 
\end_layout

\begin_deeper
\begin_layout Standard

\lang english
tree(1,tree(2,nil,nil),tree(3,nil,nil)).
\end_layout

\begin_layout Standard

\lang english
tree(a, tree(b,tree(d,nil,nil),tree(e,nil,nil)), tree(c,tree(f,nil,nil),tree(g,n
il,nil))).
 
\end_layout

\end_deeper
\begin_layout Enumerate
כתבנו פרדיקט בשם 
\begin_inset Formula $binarytree$
\end_inset

 המסתפק אמ"מ הקלט שלו הוא עץ בינארי.
 ע"פ הגדרה - הפרדיקט מסתפק עבור 
\begin_inset Formula $nil$
\end_inset

 או עבור 
\begin_inset Formula $tree$
\end_inset

 כאשר הפרמטר הראשון שלו הוא ש"ע שרירותי ו-
\begin_inset Formula $binarytree$
\end_inset

 מסתפק על שני הפרמטרים הבאים.
\end_layout

\begin_layout Enumerate
כתבנו את הפרידקט 
\begin_inset Formula $full$
\end_inset

 המסתפק אמ"א הקלט שלו הוא עץ בינארי מלא.
 הפרדיקט יסתפק עבור 
\begin_inset Formula $nil$
\end_inset

, עבור 
\begin_inset Formula $tree$
\end_inset

 עם משתנה ראשון כלשהו ושני הבאים 
\begin_inset Formula $nil$
\end_inset

 )עלה(, או עבור 
\begin_inset Formula $tree$
\end_inset

 כאשר שני המשתנים הבאים אינם 
\begin_inset Formula $nil$
\end_inset

, ו-
\begin_inset Formula $full$
\end_inset

 מסתפק עליהם.
\end_layout

\begin_layout Enumerate
כתבנו את הפריקט 
\begin_inset Formula $depth$
\end_inset

 המחשב את העומק של העץ הבינארי שניתן לו כפרמטר ראשון, ומסתפק אמ"מ הוא זהה
 לפרמטר השני שניתן לו.
 
\begin_inset Formula $depth$
\end_inset

 על 
\begin_inset Formula $nil$
\end_inset

 מוגדר להיות אפס, במקרה של עץ בינארי מורכב יותר 
\begin_inset Formula $depth$
\end_inset

 תקרא רקורסיבית על שני הבנים ותדרוש שהעומק של העץ יהיה אחד יותר מהמקסימום
 בין שתי הקריאות )על שני הבנים(.
\end_layout

\begin_layout Enumerate
כתבנו את הפרדיקט 
\begin_inset Formula $complete$
\end_inset

 המסתפק אמ"מ הפרמטר שניתן לו הוא עץ בינארי שלם.
 השתמשנו בפרדיקט עזר בשם - 
\begin_inset Formula $completedepth$
\end_inset

 המקבל שני פרמטרים ומסתפק אמ"מ הראשון הוא עץ בינארי שלם בעומק השווה לשני.
 הפרדיקט הזה מחושב רקורסיבית, כאשר הוא דורש שהאיבר הראשון יהיה 
\begin_inset Formula $nil$
\end_inset

 והעומק 
\begin_inset Formula $0$
\end_inset

 או ששני הבנים יחזירו את אותו עומק.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Formula $complete\left(T\right)$
\end_inset

 יסתפק אמ"מ קיים עומק כלשהו 
\begin_inset Formula $N$
\end_inset

 עבורו 
\begin_inset Formula $completedepth\left(T,N\right)$
\end_inset

 יסתפק.
\end_layout

\end_deeper
\begin_layout Enumerate
מימשנו את הפרדיקט 
\begin_inset Formula $getnodesinorder\left(T,X\right)$
\end_inset

 המציב ל-
\begin_inset Formula $X$
\end_inset

 בזה אחר זה את כל הצמתים של 
\begin_inset Formula $T$
\end_inset

 בסדר 
\begin_inset Formula $inorder$
\end_inset

.
 הפרדיקט יציב ל-
\begin_inset Formula $X$
\end_inset

 את ש"ע המתאים אם 
\begin_inset Formula $T$
\end_inset

 הוא עלה )מהצורה - 
\begin_inset Formula $tree\left(\_,nil,nil\right)$
\end_inset

(, או יקרא לעצמו רקורסיבית על העלה השמאלי, אז )אם "או" בין המקרים( יציב
 את שם העצם המתאים ואז יקרא לעצמו על הימני - אם הם לא 
\begin_inset Formula $nil$
\end_inset

.
\end_layout

\end_body
\end_document
